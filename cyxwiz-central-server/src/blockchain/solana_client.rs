//! Real Solana SDK integration for CyxWiz Central Server
//!
//! This module provides blockchain connectivity for:
//! - Wallet management and balance queries
//! - Transaction signing and submission
//! - JobEscrow smart contract interaction

use crate::error::{Result, ServerError};
use solana_client::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig,
    hash::Hash,
    instruction::{AccountMeta, Instruction},
    pubkey::Pubkey,
    signature::{Keypair, Signature, Signer},
    transaction::Transaction,
};
use std::str::FromStr;
use std::sync::Arc;
use tracing::{debug, info, warn};

/// Re-export common types for use throughout the blockchain module
pub use solana_sdk::instruction::AccountMeta as SolanaAccountMeta;
pub use solana_sdk::pubkey::Pubkey as SolanaPubkey;
pub use solana_sdk::signature::Signature as SolanaSignature;

/// Solana blockchain client for CyxWiz payment operations
///
/// Handles:
/// - RPC communication with Solana network
/// - Transaction signing with payer keypair
/// - Balance and account queries
#[derive(Clone)]
pub struct SolanaClient {
    rpc_client: Arc<RpcClient>,
    payer: Arc<Keypair>,
    program_id: Pubkey,
}

impl SolanaClient {
    /// Create a new SolanaClient with explicit keypair bytes
    ///
    /// # Arguments
    /// * `rpc_url` - Solana RPC endpoint (e.g., "https://api.devnet.solana.com")
    /// * `payer_bytes` - 64-byte keypair (32 private + 32 public)
    /// * `program_id` - JobEscrow program address
    pub fn new(rpc_url: &str, payer_bytes: &[u8], program_id: &str) -> Result<Self> {
        let payer = Keypair::from_bytes(payer_bytes)
            .map_err(|e| ServerError::Blockchain(format!("Invalid keypair bytes: {}", e)))?;

        let program_id = Pubkey::from_str(program_id)
            .map_err(|e| ServerError::Blockchain(format!("Invalid program ID: {}", e)))?;

        let rpc_client = RpcClient::new_with_commitment(
            rpc_url.to_string(),
            CommitmentConfig::confirmed(),
        );

        info!("Solana client initialized");
        debug!("RPC URL: {}", rpc_url);
        debug!("Program ID: {}", program_id);
        debug!("Payer pubkey: {}", payer.pubkey());

        Ok(Self {
            rpc_client: Arc::new(rpc_client),
            payer: Arc::new(payer),
            program_id,
        })
    }

    /// Create a SolanaClient from a keypair file (Solana CLI format)
    ///
    /// The keypair file should be a JSON array of 64 bytes, as generated by:
    /// `solana-keygen new -o ~/.config/solana/id.json`
    ///
    /// # Arguments
    /// * `rpc_url` - Solana RPC endpoint
    /// * `keypair_path` - Path to JSON keypair file
    /// * `program_id` - JobEscrow program address
    pub fn from_keypair_file(rpc_url: &str, keypair_path: &str, program_id: &str) -> Result<Self> {
        // Expand ~ to home directory if present
        let expanded_path = shellexpand::tilde(keypair_path).to_string();

        // Check if file exists
        if !std::path::Path::new(&expanded_path).exists() {
            return Err(ServerError::Blockchain(format!(
                "Keypair file not found: {}",
                expanded_path
            )));
        }

        // Read keypair file
        let keypair_data = std::fs::read_to_string(&expanded_path)
            .map_err(|e| ServerError::Blockchain(format!("Failed to read keypair file: {}", e)))?;

        // Parse JSON array of bytes
        let keypair_bytes: Vec<u8> = serde_json::from_str(&keypair_data)
            .map_err(|e| ServerError::Blockchain(format!("Invalid keypair JSON format: {}", e)))?;

        if keypair_bytes.len() != 64 {
            return Err(ServerError::Blockchain(format!(
                "Invalid keypair length: expected 64 bytes, got {}",
                keypair_bytes.len()
            )));
        }

        Self::new(rpc_url, &keypair_bytes, program_id)
    }

    /// Get the payer's public key
    pub fn payer_pubkey(&self) -> Pubkey {
        self.payer.pubkey()
    }

    /// Get a reference to the payer keypair (for signing transactions)
    pub fn payer(&self) -> &Keypair {
        &self.payer
    }

    /// Get the JobEscrow program ID
    pub fn program_id(&self) -> Pubkey {
        self.program_id
    }

    /// Get account balance in lamports
    ///
    /// # Arguments
    /// * `pubkey` - Account public key
    ///
    /// # Returns
    /// Balance in lamports (1 SOL = 1_000_000_000 lamports)
    pub async fn get_balance(&self, pubkey: &Pubkey) -> Result<u64> {
        let balance = self.rpc_client
            .get_balance(pubkey)
            .map_err(|e| ServerError::Blockchain(format!("Failed to get balance: {}", e)))?;

        debug!("Balance for {}: {} lamports ({} SOL)",
            pubkey,
            balance,
            balance as f64 / 1_000_000_000.0
        );

        Ok(balance)
    }

    /// Get the latest blockhash for transaction signing
    pub async fn get_latest_blockhash(&self) -> Result<Hash> {
        self.rpc_client
            .get_latest_blockhash()
            .map_err(|e| ServerError::Blockchain(format!("Failed to get blockhash: {}", e)))
    }

    /// Send a signed transaction to the network
    ///
    /// # Arguments
    /// * `transaction` - Signed transaction to send
    ///
    /// # Returns
    /// Transaction signature as string
    pub async fn send_transaction(&self, transaction: Transaction) -> Result<String> {
        let signature = self.rpc_client
            .send_and_confirm_transaction(&transaction)
            .map_err(|e| ServerError::Blockchain(format!("Transaction failed: {}", e)))?;

        info!("Transaction sent: {}", signature);
        Ok(signature.to_string())
    }

    /// Send and confirm a transaction with custom commitment
    pub async fn send_and_confirm_transaction(
        &self,
        transaction: &Transaction,
    ) -> Result<Signature> {
        self.rpc_client
            .send_and_confirm_transaction(transaction)
            .map_err(|e| ServerError::Blockchain(format!("Transaction failed: {}", e)))
    }

    /// Confirm a transaction by signature
    ///
    /// # Arguments
    /// * `signature` - Transaction signature to confirm
    ///
    /// # Returns
    /// true if confirmed, false if not yet confirmed
    pub async fn confirm_transaction(&self, signature: &str) -> Result<bool> {
        let sig = Signature::from_str(signature)
            .map_err(|e| ServerError::Blockchain(format!("Invalid signature: {}", e)))?;

        match self.rpc_client.confirm_transaction(&sig) {
            Ok(confirmed) => Ok(confirmed),
            Err(e) => {
                warn!("Transaction confirmation check failed: {}", e);
                Ok(false)
            }
        }
    }

    /// Get account data (for reading escrow state)
    ///
    /// # Arguments
    /// * `pubkey` - Account public key
    ///
    /// # Returns
    /// Raw account data bytes
    pub async fn get_account_data(&self, pubkey: &Pubkey) -> Result<Vec<u8>> {
        let account = self.rpc_client
            .get_account(pubkey)
            .map_err(|e| ServerError::Blockchain(format!("Failed to get account: {}", e)))?;

        Ok(account.data)
    }

    /// Check if an account exists
    pub async fn account_exists(&self, pubkey: &Pubkey) -> Result<bool> {
        match self.rpc_client.get_account(pubkey) {
            Ok(_) => Ok(true),
            Err(_) => Ok(false),
        }
    }

    /// Build and sign a transaction with the payer
    ///
    /// # Arguments
    /// * `instructions` - Instructions to include in transaction
    ///
    /// # Returns
    /// Signed transaction ready to send
    pub async fn build_and_sign_transaction(
        &self,
        instructions: &[Instruction],
    ) -> Result<Transaction> {
        let blockhash = self.get_latest_blockhash().await?;

        let transaction = Transaction::new_signed_with_payer(
            instructions,
            Some(&self.payer.pubkey()),
            &[&*self.payer],
            blockhash,
        );

        Ok(transaction)
    }

    /// Build, sign, and send a transaction
    ///
    /// Convenience method that combines build_and_sign_transaction and send_transaction
    pub async fn execute_transaction(&self, instructions: &[Instruction]) -> Result<String> {
        let transaction = self.build_and_sign_transaction(instructions).await?;
        self.send_transaction(transaction).await
    }

    /// Get minimum rent-exempt balance for an account size
    pub async fn get_minimum_balance_for_rent_exemption(&self, data_len: usize) -> Result<u64> {
        self.rpc_client
            .get_minimum_balance_for_rent_exemption(data_len)
            .map_err(|e| ServerError::Blockchain(format!("Failed to get rent exemption: {}", e)))
    }
}

/// Helper functions for PDA derivation
pub mod pda {
    use super::*;

    /// Derive the escrow PDA for a given job ID
    ///
    /// Seeds: ["escrow", job_id.to_le_bytes()]
    pub fn find_escrow_address(program_id: &Pubkey, job_id: u64) -> (Pubkey, u8) {
        Pubkey::find_program_address(
            &[b"escrow", &job_id.to_le_bytes()],
            program_id,
        )
    }

    /// Derive the escrow token account PDA
    ///
    /// Seeds: ["escrow_token", job_id.to_le_bytes()]
    pub fn find_escrow_token_account(program_id: &Pubkey, job_id: u64) -> (Pubkey, u8) {
        Pubkey::find_program_address(
            &[b"escrow_token", &job_id.to_le_bytes()],
            program_id,
        )
    }
}

/// System program ID constant
pub fn system_program_id() -> Pubkey {
    solana_sdk::system_program::id()
}

/// SPL Token program ID
pub fn token_program_id() -> Pubkey {
    spl_token::id()
}

/// Associated Token Account program ID
pub fn associated_token_program_id() -> Pubkey {
    spl_associated_token_account::id()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_pda_derivation() {
        let program_id = Pubkey::from_str("DefY4GG33pAgBJqwPKDSKbPbCKmoCcN8oymvHhzsp2dA").unwrap();
        let job_id: u64 = 12345;

        let (escrow_pda, bump) = pda::find_escrow_address(&program_id, job_id);

        // PDA should be deterministic
        let (escrow_pda2, bump2) = pda::find_escrow_address(&program_id, job_id);
        assert_eq!(escrow_pda, escrow_pda2);
        assert_eq!(bump, bump2);

        // Different job_id should give different PDA
        let (other_pda, _) = pda::find_escrow_address(&program_id, job_id + 1);
        assert_ne!(escrow_pda, other_pda);
    }

    #[test]
    fn test_pubkey_parsing() {
        let pubkey_str = "DefY4GG33pAgBJqwPKDSKbPbCKmoCcN8oymvHhzsp2dA";
        let pubkey = Pubkey::from_str(pubkey_str).unwrap();
        assert_eq!(pubkey.to_string(), pubkey_str);
    }
}
